=============================================================================================================================================================
1.
Направете скрипта која за секој активен процес прво го печати неговиот ID, па бројот на неговиот татко,
па ве прашува дали да го убие процесот, и во зависност од одговорот изведува соодветна акција.	

ps -l|cat > dat.tmp
m=`cat dat.tmp|wc -l`
m=`expr $m - 1`
`tail -$m dat.tmp > temp.tmp`
`cat temp.tmp > dat.tmp`
awk '{print $2}' dat.tmp > PID
awk '{print $3}' dat.tmp > PPID
echo "Brojot na procesi e:" $m
count1=1
count2=1
for i in `cat PID`
do
   count2=1
   tmpPID=$i
   for j in `cat PPID`
   do
      if [ $count1 -eq $count2 ] 
      then
         tmpPPID=$j
      fi
      count2=`expr $count2 + 1`
   done
   count1=`expr $count1 + 1`
   echo "PROCES PID: " $tmpPID " PPID: " $tmpPPID
   echo "Dali sakate da go izbrisete procesot? (d/n)"
   read odg
   if [ $odg = "d" ]
   then 
      kill -1 $tmpPID
   fi
done

2.
Да се креира скрипта avtomat со следново својство: под претпоставка дека во тековниот директориум постои скриптата skripta,
која се повикува со еден аргумент, скриптата avtomat ќе ја извршува skripta со аргумент кој го задава корисникот за време на 
извршувањето на avtomat.. Извршувањето ќе се повторува се додека корисникот не го внесе зборот kraj. Излезот од секое извршување 
на skripta да се пренасочува во датотеката izlez.txt.
На пример, ако skripta го печати својот аргумент, тогаш ако кoрисникот ги внесува последователно зборовите Denes, Utre,
Zadutre, kraj, во датотеката izlez треба да се наоѓаат зборовите  Denes, Utre, Zadutre, секој во нов ред.


#!/bin/bash

touch izlez.txt
while true; do
echo -n  "Vnesete argumenti za skriptata ( ako sakate da prekinete pisete kraj)"
read input
if [ $input == "kraj" ]; then
break
fi
./script "$input" >> izlez.txt
done

3.
 Да се најдат (временски) најновите 7 датотеки  во тековниот директориум чиешто име започнува со poc.
#!/bin/bash

i=7
s="poc'
echo "Datoteki koi zapocnuvaat so poc"
ls -l $s* |grep ^-.*|sort
echo "ima `ls -l $s*|grep ^-.*|wc -l` takvi datoteki."
echo  "od koi $i najnovi se:"
ls -l $s*|grep ^-.*|sort -k 7 |tail -$i

4.
Да се најде колку меморија зафаќаат датотеките во тековниот директориум кои имаат наставка .dat.

c=0
sum=0
for i in `ls -l *.dat`
do
c=`expr $c+1`
if [ $c -eq 5 ]; then
sum=`expr $sum+$i`
fi
if [ $c -eq 9 ]; then
c=0
fi
done
echo "vkupnata golemina e: $sum"
echo
echo "So gotova funkcija goleminata e: `du -bc *.dat|tail -1|awk '{print $1}'`

5.
Да претпоставиме дека сакате да испратите едно исто писмо на повеќе луѓе со корисничко име на системот на
кој сте најавени, со тоа што при обраќање кон личноста сакате да го користите нејзиното лично име, кое е исто 
како корисничкото. Направете скрипта која ќе користи две датотеки: една iminja во која се наоѓаат имињата на вашите пријатели 
и една pismo во која наместо името стои IME, 
и со едно извршување на скриптата писмото ќе биде испратено до сите, со лично обраќање до секого.  


#!/bin/bash
for i in `cat iminja.txt`
do
touch $i.proba
echo "Zdravo $i">>$i.proba
cat poraka.txt>>$i.proba
mail $i<$i.proba
done

5.
Направете, во вид на скрипта, команда за безбедно бришење. Датотеките дадени како аргументи на скриптата не се 
отстрануваат, туку се преместуваат 
во директориумот ~/gjubre.На крај, скриптата ги отстранува сите датотеки од овој директориум кои се постари од еден ден. 

mesec=`date | awk '{ print $2 }'`
datum=`date | awk '{ print $3 }'`
if [ -d ~/gjubre ]
then
	rm -r ~/gjubre
fi
mkdir ~/gjubre
for i in $*
do
	mv $i ~/gjubre
done
cd ~/gjubre
for j in `ls`
do
	m=`ls -l $j | awk '{ print $6 }'`
	d=`ls -l $j | awk '{ print $7 }'`
	if [ ! $mesec = $m -o ! $datum = $d ]
	then
		echo "Ja brisam $j"
		rm $j
	fi
done

6.
Излистајте ги во посебна датотека сите датотеки во вашиот домашен директориум кои се модифицирани 
во тековниот ден (потешка но незадолжителна варијанта: модифицирани во последните 24 часа. Уште потешка: 
наместо во домашниот директориум, во неговото дрво).


#!/bin/bash
if [ -f modificirani ]; then
rm  modificirani
fi

touch modificirani

mesec=`date|awk '{print $2}'`
datum=`date|awk '{print $3}'`
for i in `ls`
do
if [ -f $i ]; then
m=`ls -l $i|awk '{print $6}'`
d=`ls -l $i|awk '{print $7}'`
if [ $mesec =$m -a $datum =$d ];then
echo $i>>modificirani
fi
fi
done

7.
Направете скрипта која на секои 10 секунди ќе проверувадали корисникот student е најавен на системот, 
се додека тој не се најави(со користење на наредбата sleep n , каде n е бројот на секунди). 

while true; then
if who| grep -q "^$username";then
echo "Studentot e logiran"
break
else
echo "Studentot ne e lofiran"
fi
sleep 10
done

8.  Да се направи скрипта која прво проверува дали во тековниот директориум постои поддиректориум backup и доколку не постои го креира. 
Потоа сите датотеки од тековниот директориум ги копира во директориумот backup при сто им додава наставка .backup.

#!/bin/bash

if [ -d backup ];then
echo "Vekje postoi backup datoteka"
else
echo "Kreirame datoteka backup"
mkdir backup
fi
for i in `ls` ; do
if [ -f $i ];then
cp $i backup/
fi
done
cd backup/
echo " Im dodavame nastavka .backup na datotekite"
for i in `ls`
mv $i "$i.backup"
done

9. Со командата date може да се добие денешниот датум. Да претпоставиме дека во вашиот (тековниот) директориум се наоѓаат 3 датотеки со имиња neparen, 
paren, vikend. Да се направи скрипта која во деновите понеделник, среда и петок ќе ја печати на екран содржината на датотеката neparen, во вторник и 
четврток датотеката paren и во сабота и недела датотеката vikend.

#!/bin/bash
v=`date|awk '{print $1}'`

case $v in
Monday)
cat nepraren;;
Tuesday)
cat paren;;
Wednesday)
cat neparen;;
Thursday)
cat paren;;
Friday)
cat neparen;;;
Saturday)
cat vikend;;
Sunday)
cat vikend;;
esac


============================================================================================================================================================
